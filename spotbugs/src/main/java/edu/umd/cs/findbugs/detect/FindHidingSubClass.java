/*
 * SpotBugs - Find bugs in Java programs
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package edu.umd.cs.findbugs.detect;

import edu.umd.cs.findbugs.BugInstance;
import edu.umd.cs.findbugs.Detector;
import edu.umd.cs.findbugs.SourceLineAnnotation;
import edu.umd.cs.findbugs.ba.ClassContext;
import org.apache.bcel.generic.BasicType;
import edu.umd.cs.findbugs.BugReporter;
import edu.umd.cs.findbugs.ba.AnalysisContext;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.Type;

import java.util.Arrays;

/**
 * This detector finds all the methods of a subclass which are hiding the static methods of the superclass and
 * tries to invoke that method using the instance variable.
 * Please see @see <a href="https://wiki.sei.cmu.edu/confluence/display/java/MET07-J.+Never+declare+a+class+method+that+hides+a+method+declared+in+a+superclass+or+superinterface">SEI CERT MET07-J</a>
 * @author Nazir, Muhammad Zafar Iqbal
 */
public class FindHidingSubClass implements Detector {
    private final BugReporter bugReporter;

    public FindHidingSubClass(BugReporter bugReporter) {
        this.bugReporter = bugReporter;
    }

    /**
     * This method analyze only the super classes, not the super interface.
     * Because in case of the only existing test cases,
     * we need to call the static method over the class - a compliant test case as per SEI CERT MET07-J rule.
     * Thereof, it is useless to check this in our detector.
     * Although both compliant and non-complaint test cases are added for it.
     */
    @Override
    public void visitClassContext(ClassContext classContext) {
        //First, I get the subclass and superclasses in variables.
        //This is the current class. Named it subClass to better depict the idea of sub and super class.
        JavaClass subClass = classContext.getJavaClass();
        //No need for null check as every class has at least `Object` as its super class.
        JavaClass[] superClasses = null;
        try {
            superClasses = subClass.getSuperClasses();
        } catch (ClassNotFoundException e) {
            AnalysisContext.reportMissingClass(e);
        }
        //I store all the methods of both subclass (in separate variables)
        Method[] methods = subClass.getMethods();
        //For each super class, I go through each method of the subclass and filter the non-private and static methods, as private methods can't be overridden.
        //I also perform check for main method using auxiliary private method
        for (JavaClass superClass : superClasses) {
            for (Method method : methods) {
                // Careful!!! regarding the order of the conditions applied here
                // Taking advantage of short circuit evaluation here by placing !isMainMethod(method)
                if (method.isStatic() && !method.isPrivate() && !isMainMethod(method)) {
                    Method[] superMethods = superClass.getMethods();
                    //I check either the method of subclass is present in the super class.
                    // If it is, I store it in a variable for further usage.
                    int index = Arrays.asList(superMethods).indexOf(method);
                    Method superClassMethod;
                    if (index != -1) {
                        superClassMethod = superMethods[index];
                    } else {
                        continue;
                    }
                    //Here I check for the exceptional cases of main method and inner class using three auxiliary private methods.
                    if (isConstructor(method) || isHidingInnerClass(method) || isAutoGeneratedMethod(method)) {
                        continue;
                    }
                    //I check using an auxiliary private method, either the subclass method is hiding the superclass method.
                    //If yes, then I report the bug.
                    if (isHiding(superClassMethod, method)) {
                        bugReporter.reportBug(new BugInstance(this, "HSBC_HIDING_SUB_CLASS", NORMAL_PRIORITY)
                                .addClass(subClass.getClassName())
                                .addMethod(subClass, method)
                                .addString(subClass.getClassName())
                                .addString(superClassMethod.getName())
                                .addString(superClass.getClassName())
                                .addSourceLine(SourceLineAnnotation.fromVisitedInstruction(subClass, method, 0)));
                    }
                }
            }
        }
    }

    @Override
    public void report() {
    }


    /**
     *This method checks for the inner class exceptional cases.
     *As whenever there an inner class, '.access$' methods are created hiddenly to access the outer class attributes.
     */
    private boolean isHidingInnerClass(Method method) {
        return method.getName().contains("access$");
    }

    /**
     *This method checks for the autoGenerated methods for an inner class - exceptional cases.
     *As whenever there an inner class, '.class$' methods are created hiddenly.
     */
    private boolean isAutoGeneratedMethod(Method method) {
        return method.getName().contains("class$");
    }

    /**
     * This method checks for the exceptional case of main method.
     * As we know main method always have the signature "public static void main(String[] args)".
     * It is static but usually public class have its own main method as its entry point.
     * Therefore, it is not a error caused by Programming but a utility to provide UI to user.
     */
    private boolean isConstructor(Method method) {
        return method.getName().contains("clinit") || method.getName().contains("init");
    }

    /**
     * This method checks either the received method is entry point for class or not.
     * It does by checking public static void main(String[] args) signature element by element.
     */
    private boolean isMainMethod(Method method) {
        return method.isPublic() && method.isStatic() && method.getReturnType().equals(BasicType.VOID)
                && "main".equals(method.getName())
                && this.isStringArray(method.getArgumentTypes());
    }

    private boolean isStringArray(Type[] methodArguments) {
        return methodArguments.length == 1 &&
                methodArguments[0].toString().contains("String") &&
                methodArguments[0].toString().contains("[");
    }

    /**
     * This method checks either the method 'overrider' in subClass is actually overriding the method 'overridden' in superclass
     * It then checks the name, signature and 'overridden' being non-final constraints of overriding.
     */
    private boolean isOverriding(Method overridden, Method overrider) {
        return overridden.getName().equals(overrider.getName())
                && Arrays.equals(overridden.getArgumentTypes(), overrider.getArgumentTypes())
                && !overridden.isFinal();
    }

    /**
     * This method checks the hiding constraints.
     */
    private boolean isHiding(Method original, Method overrider) {
        return isOverriding(original, overrider) && original.getReturnType().equals(overrider.getReturnType());
    }
}
